# -*- coding: utf-8 -*-
"""Collab_Tratamento_Netflix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oWVQSI7Dt01RaCvzovo8kzl03x-4vdqs
"""

# Importando a biblioteca

import pandas as pd
import numpy as np
import sqlite3
import gdown

"""**1. EXTRAÇÃO**"""

# Carregamento inicial dos dados brutos
# ID do arquivo
arquivo_id = "1A4MVsMqteVw2aNvIAGNvwciOs6rEMMkv"

# Monta a URL para o gdown
url = f"https://drive.google.com/uc?id={arquivo_id}"
output = "netflix.csv"

gdown.download(url, output, quiet=False)

try:
 df_netflix_titles = pd.read_csv("netflix.csv")
 print("Arquivo extraído com sucesso!")

 print("Visualização das 5 primeiras linhas do dataset:")

except FileNotFoundError:
 print(f"Erro: Arquivo não encontrado")

df_netflix_titles.head()

# Exibição de tipos de colunas
df_netflix_titles.info()

print("\Contagem de calores nulos por Coluna:")
print(df_netflix_titles.isnull().sum())

print("Visualizando linhas com dados faltantes:")
#Apenas linhas que tem pelo menos um campo vazio
print(df_netflix_titles[df_netflix_titles.isnull().any(axis=1)].head())

print("\Estatísticas")
print(df_netflix_titles['release_year'].describe())

"""**2. TRANSFORMAÇÃO**"""

# Criada uma cópia para a camada silver

df_silver = df_netflix_titles.copy()

# Limpeza Inicial

# Removidas duplicatas
df_silver.drop_duplicates(inplace=True)

# Para validar se há duplicidades
numero_de_duplicatas_restantes = df_silver.duplicated().sum()
if numero_de_duplicatas_restantes == 0:
    print("✅ Sucesso! Todas as duplicatas foram removidas.")
else:
    print(f"⚠️ Atenção! Ainda existem {numero_de_duplicatas_restantes} duplicatas.")

# Tratamento de nulos: Preencher com 'Desconhecido'
dicionario = {
    'director': 'Diretor Desconhecido',
    'cast': 'Elenco Desconhecido',
    'country': 'País Desconhecido'
}

df_silver.fillna(dicionario, inplace=True)

# Para validar se há nulos

# Lista das colunas que foram tratadas
colunas_tratadas = ['director', 'cast', 'country']

# Série com a contagem de nulos nas colunas tratadas
contagem_nulos = df_silver[colunas_tratadas].isnull().sum()
print("Contagem de nulos restantes")
print(contagem_nulos)
print("---------------------------------------")


total_nulos_restantes = contagem_nulos.sum()
if total_nulos_restantes == 0:
    print("✅ Sucesso! Não há mais valores nulos nas colunas 'director', 'cast' e 'country'.")
else:
    print(f"⚠️ Atenção! Ainda existem {total_nulos_restantes} valores nulos nessas colunas. Verifique a execução anterior.")

# Removidos espaços em branco no início e fim de todas as colunas de texto
for col in df_silver.select_dtypes(include='object').columns:
    df_silver[col] = df_silver[col].str.strip()

# Validar espaços em branco nos textos

# Identificar as colunas de texto (object)
colunas_texto = df_silver.select_dtypes(include='object').columns
total_problemas = 0
resultados_por_coluna = {}

print("Verificação de espaços que restaram")


for col in colunas_texto:
    # Checar se há valores que começam ou terminam com espaço
    tem_espaco_inicio = df_silver[col].astype(str).str.startswith(' ').sum()
    tem_espaco_fim = df_silver[col].astype(str).str.endswith(' ').sum()

    total_coluna = tem_espaco_inicio + tem_espaco_fim

    if total_coluna > 0:
        resultados_por_coluna[col] = total_coluna

    total_problemas += total_coluna

# Resultados
if total_problemas == 0:
    print("✅ Sucesso! Nenhum espaço em branco encontrado no início ou fim das colunas de texto.")
else:
    print(f"⚠️ Atenção! Encontrados {total_problemas} problemas de espaços em branco remanescentes nas seguintes colunas:")
    for col, count in resultados_por_coluna.items():
        print(f"  - Coluna '{col}': {count} ocorrências de espaço no início/fim.")

#Padronizados nomes para Primeira Maiúscula

colunas_titulos = ['title', 'director', 'cast']
for col in colunas_titulos:
    df_silver[col] = df_silver[col].str.title()

colunas_titulos = ['title', 'director', 'cast']
total_inconformidades = 0
inconformidades_por_coluna = {}

print("Verificação de Inconformidades")

for col in colunas_titulos:
    # Checa se o valor original é diferente do valor após a re-aplicação do .str.title()
    # Se forem diferentes, o valor original (após a sua execução) não estava no formato correto.
    inconforme = (df_silver[col] != df_silver[col].str.title())
    count = inconforme.sum()

    if count > 0:
        inconformidades_por_coluna[col] = count
        total_inconformidades += count

if total_inconformidades == 0:
    print("✅ Sucesso! Os valores nas colunas 'title', 'director' e 'cast' estão padronizados no formato Title Case (Primeira Maiúscula).")
else:
    print(f"⚠️ Atenção! Encontradas {total_inconformidades} inconformidades no formato Title Case nas seguintes colunas:")
    for col, count in inconformidades_por_coluna.items():
        print(f"  - Coluna '{col}': {count} valores fora do padrão esperado.")

# Dicionário de unificação dos países
map_paises = {
    'united states': 'United States',
    'u.s.a.': 'United States',
    'usa': 'United States',
    'brasil': 'Brazil',
    'brazil': 'Brazil',
    'uk': 'United Kingdom',
    'u.k.': 'United Kingdom',
    'england': 'United Kingdom',
    'south korea': 'Korea, Republic of',
    'republic of korea': 'Korea, Republic of'
}

# Aplicação da unificação
df_silver['country'] = df_silver['country'].str.lower().replace(map_paises)

# Dicionário de Classificação Etária para padrão Brasil
# Livre, 10+, 12+, 14+, 16+, 18+
classificacao = {
        'TV-Y': 'Livre', 'TV-G': 'Livre', 'G': 'Livre', 'TV-Y7': '10+',
        'TV-Y7-FV': '10+', 'PG': '10+', 'PG-13': '12+', 'TV-14': '14+',
    'R': '16+', 'TV-MA': '18+', 'NR': 'Não Classificado', 'UR': 'Não Classificado'
}

df_silver['rating_br'] = df_silver['rating'].map(classificacao).fillna('Outros')

# Ver se a nova coluna 'rating_br'tem 6 classificações
print("Distribuição da Classificação Etária (rating_br)")
print(df_silver['rating_br'].value_counts(dropna=False))

print("\n--------------------------------------------------------------")
print("✅ Verifique se o resultado inclui apenas as 6 classificações BR (Livre, 10+, 12+, 14+, 16+, 18+), 'Não Classificado' e 'Outros'.")

# Ajuste datas e tipos
#Convertidas date_added para datetime
df_silver['date_added'] = pd.to_datetime(df_silver['date_added'], format='mixed', errors='coerce')

# Checa o tipo de dado da coluna 'date_added'
dtype_atual = df_silver['date_added'].dtype

if dtype_atual == 'datetime64[ns]':
    print("✅ Sucesso! A coluna 'date_added' foi convertida para o tipo datetime (datetime64[ns]).")
else:
    print(f"⚠️ Atenção! A coluna não é do tipo datetime. O dtype encontrado é: {dtype_atual}")

#Criadas colunas de Ano e Mês de adição
df_silver['ano_adicionado'] = df_silver['date_added'].dt.year
df_silver['mes_adicionado'] = df_silver['date_added'].dt.month_name()

df_silver.head()

# Calculado intervalo entre o lançamento e a adição na plataforma
df_silver['lancamento_adicao'] = df_silver['ano_adicionado'] - df_silver['release_year']

# Colunas para conferir
colunas_teste = ['release_year', 'ano_adicionado', 'lancamento_adicao']

# Seleciona 5 linhas aleatórias
amostra_calculo = df_silver[colunas_teste].sample(5)

print("\n--- Amostra da Lógica de Cálculo (5 Linhas) ---")
print(amostra_calculo)

print("\n--- Confirmação ---")
print("✅ Verifique visualmente na amostra se: 'ano_adicionado' - 'release_year' = 'lancamento_adicao'.")

# Duração - Separar valor númerico da unidade (min vs seasons)
df_silver[['duration_valor', 'duration_unidade']] = df_silver['duration'].str.split(' ', expand=True)
df_silver['duration_valor'] = pd.to_numeric(df_silver['duration_valor'], errors='coerce')

# Cria uma coluna de resumo da duração
df_silver['duracao_resumo'] = df_silver['duration_valor'].astype(str) + ' ' + df_silver['duration_unidade']

print("--- Amostra da Coluna 'duracao_resumo' ---")
print(df_silver[['title', 'type', 'duracao_resumo']].sample(5))

# Converter para Inteiro INT
df_silver['duration_valor'] = df_silver['duration_valor'].fillna(0).astype(int)

# Amostra visual
colunas_teste = ['duration', 'duration_valor', 'duration_unidade']

# Seleciona 5 linhas aleatórias para verificação
amostra_split = df_silver[colunas_teste].sample(5)

print("\n--- Amostra do Split e Conversão (5 Linhas) ---")
print(amostra_split)

print("\n--- Confirmação ---")
print("✅ Verifique visualmente se a coluna 'duration' foi dividida corretamente entre 'duration_valor' (número) e 'duration_unidade' (min/seasons).")

# Novas Colunas

# Gênero principal (primeiro da lista)
df_silver['genero_principal'] = df_silver['listed_in'].str.split(',').str[0].str.strip()

#País principal (primeiro da lista)
df_silver['pais_principal'] = df_silver['country'].str.split(',').str[0].str.strip()

# Tabela dimensão para 'genero_principal'
generos_unicos = df_silver['genero_principal'].unique()
df_dim_generos = pd.DataFrame(generos_unicos, columns=['nome_genero'])

# Criação do ID único (chave primária)
df_dim_generos.reset_index(inplace=True)
df_dim_generos.rename(columns={'index': 'id_genero_principal'}, inplace=True)

# Começa o ID em 1 para ser mais amigável
df_dim_generos['id_genero_principal'] = df_dim_generos['id_genero_principal'] + 1

# Chave Estrangeira
mapa_genero_para_id = df_dim_generos.set_index('nome_genero')['id_genero_principal'].to_dict()

# Adiciona a chave estrangeira na tabela principal (df_silver)
df_silver['id_genero_principal'] = df_silver['genero_principal'].map(mapa_genero_para_id)

print("\n--- Tabela de Gêneros (Amostra) ---")
print(df_dim_generos.head())
print("\n--- Chave Estrangeira adicionaada à Tabela principal (Amostra) ---")
print(df_silver[['show_id', 'genero_principal', 'id_genero_principal']].head())

# Tabela de dimensão para 'pais_principal'
paises_unicos = df_silver['pais_principal'].unique()
df_dim_paises = pd.DataFrame(paises_unicos, columns=['nome_pais'])

# ID único (chave primária)
df_dim_paises.reset_index(inplace=True)
df_dim_paises.rename(columns={'index': 'id_pais_principal'}, inplace=True)

# Começa o ID em 1
df_dim_paises['id_pais_principal'] = df_dim_paises['id_pais_principal'] + 1

# Chave Estrangeira
mapa_pais_para_id = df_dim_paises.set_index('nome_pais')['id_pais_principal'].to_dict()

# Adiciona a chave estrangeira na tabela principal (df_silver)
df_silver['id_pais_principal'] = df_silver['pais_principal'].map(mapa_pais_para_id)

print("\n--- Tabela de Países (Amostra) ---")
print(df_dim_paises.head())
print("\n--- Chave Estrangeira adicionada à Tabela principal (Amostra) ---")
print(df_silver[['show_id', 'pais_principal', 'id_pais_principal']].head())

# Colunas para conferir
colunas_teste = ['listed_in', 'genero_principal', 'country', 'pais_principal']

# Seleciona 5 linhas aleatórias para verificação
amostra_split = df_silver[colunas_teste].sample(5)

print("--- Amostra da separação (5 Linhas) ---")
print(amostra_split)

print("\n--- Confirmação ---")
print("✅ Verifique visualmente se:")
print("1. 'genero_principal' é o primeiro valor de 'listed_in' (antes da vírgula).")
print("2. 'pais_principal' é o primeiro valor de 'country' (antes da vírgula).")

# Gênero Principal
print("\n--- Top 5 Gêneros Principais ---")
print(df_silver['genero_principal'].value_counts().head())

# País Principal
print("\n--- Top 5 Países Principais ---")
print(df_silver['pais_principal'].value_counts().head())

print("\n--- Confirmação ---")
print("✅ Os valores mais frequentes em 'genero_principal' e 'pais_principal' parecem limpos e corretos.")

"""**3. MODELAGEM E CARGA**"""

# Dicionário de tradução das colunas (Inglês -> Português)
rename_map = {
    # Colunas originais
    'show_id': 'id_show', 'type': 'tipo', 'title': 'título', 'director': 'diretor',
    'cast': 'elenco', 'country': 'país', 'date_added': 'data_adicionada',
    'release_year': 'ano_lancamento', 'rating': 'classificacao_indicativa',
    'duration': 'duração', 'listed_in': 'generos', 'description': 'descricao',

    # Colunas derivadas (tradução ou padronização)
    'rating_br': 'classificacao_br',
    'ano_adicionado': 'ano_adicionado',
    'mes_adicionado': 'mes_adicionado',
    'lancamento_adicao': 'tempo_adicao_plataforma',
    'duration_valor': 'duracao_valor',
    'duration_unidade': 'duracao_unidade',
    'duracao_resumo': 'duracao_resumo',
    'proporcao_catalogo': 'proporcao_catalogo',
    'genero_principal': 'genero_principal',
    'pais_principal': 'pais_principal',

    # CHAVES ESTRANGEIRAS ADICIONADAS:
    'id_genero_principal': 'id_genero_principal',
    'id_pais_principal': 'id_pais_principal'
}

# Verificação
print("✅ Colunas do DataFrame 'df_netflix_titles' traduzidas com sucesso.")
print("\nNovas colunas:")
print(df_netflix_titles.columns.tolist())

# Criadas tabelas auxiliares para analise 'um para muitos'
# Tabela Fato: Títulos (Dados principais consolidados - Camada Gold)
# Criada a cópia, após a criação de TODAS as colunas de valor (proporção, duração, etc.)
df_gold_titulos = df_silver.copy()

df_gold_titulos.rename(columns=rename_map, inplace=True) # Tradução

print("\n--- Amostra das primeiras 5 Linhas (df_gold_titulos) ---")
print(df_gold_titulos.head())

print("\n--- Confirmação ---")
print("✅ Os dados parecem ter sido copiados integralmente para a nova tabela 'df_gold_titulos'.")

#Tabela Auxiliar: Gêneros
df_gold_generos = df_silver[['show_id', 'listed_in']].copy()
df_gold_generos['genero'] = df_gold_generos['listed_in'].str.split(',')
df_gold_generos = df_gold_generos.explode('genero')
df_gold_generos['genero'] = df_gold_generos['genero'].str.strip()
df_gold_generos.rename(columns={'show_id': 'id_show'}, inplace=True)
df_gold_generos = df_gold_generos[['id_show', 'genero']]

#Tabela Auxiliar: Países
df_gold_paises = df_silver[['show_id', 'country']].copy()
df_gold_paises['paises'] = df_gold_paises['country'].str.split(',')
df_gold_paises = df_gold_paises.explode('paises')
df_gold_paises['paises'] = df_gold_paises['paises'].str.strip()
df_gold_paises.rename(columns={'show_id': 'id_show'}, inplace=True)
df_gold_paises = df_gold_paises[['id_show', 'paises']]

# Teste para a Tabela Auxiliar df_gold_paises

linhas_silver = df_silver.shape[0]
linhas_gold_paises = df_gold_paises.shape[0]

print("--- Verificação paises (df_gold_paises) ---")
print(f"Linhas em df_silver: {linhas_silver}")
print(f"Linhas em df_gold_paises: {linhas_gold_paises}")

if linhas_gold_paises >= linhas_silver:
    print("✅ Sucesso! O número de linhas é maior ou igual, confirmando que a operação explode funcionou.")
else:
    print("⚠️ Atenção! O número de linhas diminuiu, indicando um erro na criação da tabela.")

# Colunas e limpeza da última camada
print("\n--- Colunas Finais de df_gold_paises ---")
print(df_gold_paises.columns.tolist())

# Checa a limpeza da coluna 'paises' (Top 10)
print("\n--- Top 10 Países---")
print(df_gold_paises['paises'].value_counts().head(10))

# 5 Linhas
print("\n--- Amostra da Tabela df_gold_paises (5 Linhas) ---")
print(df_gold_paises[['id_show', 'paises']].sample(5))

print("\n--- Confirmação ---")
print("✅ Verifique se as colunas são apenas ['id_show', 'paises'] e se os nomes dos países estão limpos (sem espaços no início/fim).")

# Cópia da coluna de elenco
df_cast = df_silver['cast'].copy()

# Divide a string de elenco por vírgula em uma lista
df_cast = df_cast.str.split(',')

# Cada item da lista para uma nova linha
df_cast = df_cast.explode()

# Limpa espaços em branco
df_cast = df_cast.str.strip()

# Conta a frequência de cada ator
contagem_atores = df_cast.value_counts()

print("--- Top 10 atores ---")
print(contagem_atores.head(10))

# Cria uma cópia da coluna de diretores
df_director = df_silver['director'].copy()

# Divide a string de diretor por vírgula em uma lista
df_director = df_director.str.split(',')

# Cada item da lista para uma nova linha
df_director = df_director.explode()

# Limpa espaços em branco
df_director = df_director.str.strip()

# Conta a frequência de cada diretor
contagem_diretores = df_director.value_counts()

print("\n--- Top 10 Diretores ---")
print(contagem_diretores.head(10))

# Contar o número total de filmes e séries
proporcao = df_silver['type'].value_counts()

# Calcula a porcentagem
total_itens = proporcao.sum()
proporcao_percentual = (proporcao / total_itens) * 100

print("--- Proporção de Filmes e Séries no Catálogo ---")
print(proporcao)
print("\n--- Proporção Percentual (%) ---")
print(proporcao_percentual.round(2))

# Total de cada tipo
contagem_tipo = df_silver['type'].value_counts()
total = contagem_tipo.sum()

# Nova coluna com a proporção percentual
def calcular_proporcao(row):
    tipo = row['type']
    contagem = contagem_tipo[tipo]
    return f"{((contagem / total) * 100):.2f}% de {tipo}"

df_silver['proporcao_catalogo'] = df_silver.apply(calcular_proporcao, axis=1)

print("\n--- Amostra da Coluna 'proporcao_catalogo' ---")
print(df_silver[['title', 'type', 'proporcao_catalogo']].head())

# Nova tabela - Contagem de títulos por ano de lançamento
df_contagem_por_ano = df_silver.groupby('release_year')['show_id'].count().reset_index()
df_contagem_por_ano.columns = ['ano_lancamento', 'total_titulos']

print("--- Tabela de Resumo: Títulos por ano de lançamento ---")
print(df_contagem_por_ano.sort_values(by='ano_lancamento', ascending=False).head(10))

print("\n✅ Tabela 'df_contagem_por_ano' criada com sucesso.")

# CONEXÃO COM BANCO DE DADOS LOCAL (SQLite)
conn = sqlite3.connect('projeto_netflix.db')

# Salvando as tabelas no banco de dados
try:
    df_gold_titulos.to_sql('dim_titulos', conn, if_exists='replace', index=False)
    df_gold_generos.to_sql('fato_generos', conn, if_exists='replace', index=False)
    df_gold_paises.to_sql('fato_paises', conn, if_exists='replace', index=False)
    df_dim_generos.to_sql('dim_generos', conn, if_exists='replace', index=False)
    df_dim_paises.to_sql('dim_paises', conn, if_exists='replace', index=False)
    df_gold_generos.to_sql('ponte_generos_todos', conn, if_exists='replace', index=False)
    df_gold_paises.to_sql('ponte_paises_todos', conn, if_exists='replace', index=False)

    print("Carga realizada com sucesso! Tabelas criadas")

except Exception as e:
    print(f'Erro na carga: {e}')
finally:
    conn.close()

print('\n--- Pipeline Finalizado ---')
print("O arquivo 'projeto_netflix.db' está pronto para ser conectado ao Power Bi")

